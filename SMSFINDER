import time
import random
import requests
import undetected_chromedriver as uc
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import traceback

WEBHOOK_URL = "" # Your DiscordWebhook
CHROMEDRIVER_PATH = r"" # your ChromeDriverPath
KEYWORD = "Roblox"
DISCORD_TAG = "@"  # Change to <@YOUR_USER_ID> for guaranteed ping

# Terminal color codes
GREEN = "\033[92m"
YELLOW = "\033[93m"
RED = "\033[91m"
CYAN = "\033[96m"
RESET = "\033[0m"

def random_delay(a=1.0, b=2.5):
    time.sleep(random.uniform(a, b))

def send_to_discord(number, link):
    data = {
        "content": f"ðŸ”” **Roblox Number Found!** {DISCORD_TAG}\nðŸ“± **Number:** `{number}`\nðŸ”— [Go to number page]({link})"
    }
    try:
        response = requests.post(WEBHOOK_URL, json=data)
        if response.status_code in (200, 204):
            print(f"{GREEN}âœ… Sent to Discord webhook!{RESET}")
        else:
            print(f"{RED}âŒ Failed to send to Discord: {response.status_code} {response.text}{RESET}")
    except Exception as e:
        print(f"{RED}âŒ Error sending to Discord: {e}{RESET}")

def close_popups(driver):
    try:
        close_btn = driver.find_element(By.CSS_SELECTOR, ".close, .popup-close, .adsbox, .modal-close")
        close_btn.click()
        print(f"{YELLOW}ðŸ—™ Closed popup/ad.{RESET}")
        time.sleep(1)
    except Exception:
        pass
    try:
        driver.execute_script("""
            var popups = document.querySelectorAll('.popup, .modal, .adsbox, .close, .popup-close');
            popups.forEach(function(p) { p.remove(); });
        """)
        print(f"{YELLOW}ðŸ—‘ï¸ Removed popups with JS.{RESET}")
    except Exception:
        pass

def scroll_steps(driver):
    heights = [0.15, 0.3, 0.5, 1.0]
    for h in heights:
        driver.execute_script(f"window.scrollTo(0, document.body.scrollHeight*{h});")
        time.sleep(1.2)

def wait_for_numbers(driver, timeout=15):
    try:
        WebDriverWait(driver, timeout).until(
            EC.presence_of_element_located((By.XPATH, "//a[contains(text(), '+')]"))
        )
    except Exception:
        pass

def check_smstome_com(driver):
    site = "https://smstome.com/"
    print(f"{CYAN}\nðŸŒ Checking {site} ...{RESET}")
    driver.get(site)
    random_delay(2, 4)
    close_popups(driver)
    scroll_steps(driver)

    countries = driver.find_elements(By.XPATH, "//a[contains(@href, '/country/')]")
    if not countries:
        print(f"{RED}âŒ No country links found on smstome.com!{RESET}")
        return

    total_sent = 0
    total_found = 0

    for cidx in range(len(countries)):
        countries = driver.find_elements(By.XPATH, "//a[contains(@href, '/country/')]")
        if cidx >= len(countries):
            break
        country_name = countries[cidx].text.strip() or f"Country {cidx+1}"
        print(f"{YELLOW}\nðŸš© Checking {country_name} on smstome.com ...{RESET}")
        ActionChains(driver).move_to_element(countries[cidx]).click().perform()
        random_delay(2, 4)
        close_popups(driver)
        scroll_steps(driver)
        wait_for_numbers(driver, timeout=15)

        # --- PAGINATION LOOP ---
        while True:
            scroll_steps(driver)
            wait_for_numbers(driver, timeout=10)
            checked_numbers = set()
            while True:
                numbers = driver.find_elements(By.XPATH, "//a[contains(text(), '+')]")
                found_new = False
                for n in numbers:
                    number_text = n.text.strip()
                    number_href = n.get_attribute('href')
                    if number_text in checked_numbers:
                        continue
                    checked_numbers.add(number_text)
                    # Only send if the number text contains "Roblox" (case-insensitive)
                    if KEYWORD.lower() in number_text.lower():
                        if number_href and not number_href.startswith("http"):
                            number_href = "https://smstome.com" + number_href
                        print(f"{GREEN}ðŸ”” Found: {number_text} ({number_href}){RESET}")
                        send_to_discord(number_text, number_href)
                        total_sent += 1
                    else:
                        print(f"{CYAN}ðŸ”Ž Scanned: {number_text}{RESET}")
                    total_found += 1
                    found_new = True
                if not found_new:
                    break  # All numbers on this page checked

            # Try to go to the next page using the Â» button
            next_found = False
            next_buttons = driver.find_elements(By.CSS_SELECTOR, "ul.pagination li a")
            for btn in next_buttons:
                if btn.text.strip() == "Â»" and "disabled" not in btn.get_attribute("class"):
                    try:
                        btn.click()
                        random_delay(2, 4)
                        close_popups(driver)
                        wait_for_numbers(driver, timeout=10)
                        next_found = True
                        break
                    except Exception as e:
                        print(f"{RED}Error clicking next page: {e}{RESET}")
            if not next_found:
                break  # No more pages

        driver.back()
        random_delay(2, 4)
        close_popups(driver)

    print(f"\n{GREEN}ðŸŽ‰ Done! Scanned {total_found} numbers, sent {total_sent} to Discord!{RESET}")

if __name__ == "__main__":
    try:
        driver = uc.Chrome(driver_executable_path=CHROMEDRIVER_PATH)
        try:
            check_smstome_com(driver)
        finally:
            driver.quit()
    except Exception as e:
        print(f"{RED}FATAL ERROR:{RESET}")
        traceback.print_exc()
        input("Press Enter to exit...")
